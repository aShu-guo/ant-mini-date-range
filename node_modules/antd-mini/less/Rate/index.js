import { __awaiter, __generator } from "tslib";
import { RateDefaultProps } from './props';
import createValue from '../mixins/value';
function getBoundingClientRect(selector) {
    return new Promise(function (resolve, reject) {
        my.createSelectorQuery()
            .select(selector)
            .boundingClientRect()
            .exec(function (ret) {
            if (ret && ret[0]) {
                resolve(ret[0]);
                return;
            }
            reject();
        });
    });
}
Component({
    props: RateDefaultProps,
    mixins: [createValue({
            transformValue: function (value) {
                if (this.props.allowHalf) {
                    return {
                        needUpdate: true,
                        value: value % 0.5 !== 0 ? Math.round(value) : value,
                    };
                }
                return {
                    needUpdate: true,
                    value: Math.ceil(value),
                };
            }
        })],
    methods: {
        handleStarTap: function (e) {
            return __awaiter(this, void 0, void 0, function () {
                var clientX, startTapRate, rate;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.props.readonly) {
                                return [2 /*return*/];
                            }
                            clientX = e.detail.clientX;
                            startTapRate = this.getValue();
                            return [4 /*yield*/, this.updateRate(clientX)];
                        case 1:
                            rate = _a.sent();
                            if (startTapRate === rate && this.props.allowClear) {
                                rate = 0;
                            }
                            if (!this.isControlled()) {
                                this.update(rate);
                            }
                            if (startTapRate !== rate && this.props.onChange) {
                                this.props.onChange(rate);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        },
        startMoveRate: undefined,
        handleStarMove: function (e) {
            return __awaiter(this, void 0, void 0, function () {
                var touches, clientX, rate;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.props.readonly) {
                                return [2 /*return*/];
                            }
                            touches = e.touches;
                            clientX = touches[0].clientX;
                            if (typeof this.startMoveRate === 'undefined') {
                                this.startMoveRate = this.getValue();
                            }
                            return [4 /*yield*/, this.updateRate(clientX)];
                        case 1:
                            rate = _a.sent();
                            this.update(rate);
                            return [2 /*return*/];
                    }
                });
            });
        },
        handleStarMoveEnd: function () {
            if (this.props.readonly) {
                return;
            }
            if (typeof this.startMoveRate === 'undefined') {
                return;
            }
            var startMoveRate = this.startMoveRate;
            this.startMoveRate = undefined;
            var rate = this.getValue();
            if (this.isControlled()) {
                this.update(startMoveRate);
            }
            if (startMoveRate !== rate && this.props.onChange) {
                this.props.onChange(rate);
            }
        },
        updateRate: function (clientX) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, gutter, count, _b, left, width, halfRateWidth, num, halfRateCount, val, rate;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = this.props, gutter = _a.gutter, count = _a.count;
                            return [4 /*yield*/, getBoundingClientRect("#ant-rate-container-".concat(this.$id))];
                        case 1:
                            _b = _c.sent(), left = _b.left, width = _b.width;
                            halfRateWidth = ((width - (count - 1) * gutter) / count) / 2;
                            num = clientX - left;
                            halfRateCount = 0;
                            /* eslint-disable no-constant-condition */
                            while (true) {
                                val = halfRateWidth * halfRateCount + gutter * (Math.floor(halfRateCount / 2));
                                if (halfRateCount >= count * 2 || num <= val) {
                                    break;
                                }
                                halfRateCount++;
                            }
                            rate = this.props.allowHalf ? halfRateCount * 0.5 : Math.ceil(halfRateCount * 0.5);
                            return [2 /*return*/, rate];
                    }
                });
            });
        }
    },
});
